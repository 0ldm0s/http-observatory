#!/usr/bin/env python

from __future__ import print_function
from operator import itemgetter

import argparse
import json
import requests
import sys
import time


# TODO: Update to HTTPS once real site is live
HTTP_OBS_URL = 'http://http-observatory.services.mozilla.com:5000/api/v1'


def analyze(host):
    global args

    # Keep polling the HTTP Observatory for the scan to finish
    try:
        scan = poll(HTTP_OBS_URL + '/analyze?host={host}'.format(host=host),
                    key='state',
                    values=['FINISHED'],
                    method='POST')
        grade = scan['grade']
        score = scan['score']
    except SystemExit:
        raise
    except:
        print('\nUnable to get result from the HTTP Observatory.')
        sys.exit(1)

    # Get the test results
    tests = poll(HTTP_OBS_URL + '/getScanResults?scan={scan}'.format(scan=scan['scan_id']),
                 key='x-frame-options')

    # Print the grade and scan results
    if not args.debug:
        print('Score: {score} [{grade}]'.format(score=score, grade=grade))
    else:
        print(json.dumps({'scan': scan, 'tests': tests}, indent=4, sort_keys=True))

    # Print out the reasons for score modification
    if not args.debug:
        print('Penalties:')

        # Get all the scores that aren't 0, in descending numerical order
        scores = sorted([(tests[test]['score_modifier'], tests[test]['score_description'])
                  for test in tests if tests[test]['score_modifier'] != 0])
        scores = sorted(scores, key=itemgetter(0), reverse=True)

        for score in scores:
            print('    [{modifier:>4}] {reason}'.format(modifier=score[0], reason=score[1]))


def poll(url, key, values=None, method='GET', timeout=300):
    # Create requests session
    headers = {
        'Content-Type': 'application/json',
    }
    s = requests.Session()
    s.headers.update(headers)

    # Set the start time, since we don't want to go longer than timeout seconds
    start_time = time.time()

    if args.verbose:
        print('Retrieving: {url}'.format(url=url), end='', file=sys.stderr)
        sys.stdout.flush()

    while True:
        # Retrieve the URL
        if method == 'POST':
            r = s.post(url).json()
        else:
            r = s.get(url).json()

        # See if error is in there; if so, we just abort the whole thing
        if 'error' in r:
            print('\nUnable to get result from the HTTP Observatory. Error: {error}.'.format(error=r['error']))
            sys.exit(1)

        # See if the key is one of the pollable values
        if values:
            if r[key] in values:
                if args.verbose:
                    print()
                return r
        else:
            if key in r:
                if args.verbose:
                    print()
                return r


        # Let's error out if it has taken too long
        if time.time() - start_time > timeout:
            raise requests.Timeout

        # If not, let's sleep and try again
        if args.verbose:
            print('.', end='', file=sys.stderr)
            sys.stdout.flush()
        time.sleep(3)


def usage(cmd):
    print('Usage: {0} <hostname>'.format(cmd))
    sys.exit(1)


if __name__ == "__main__":
    global args

    # Parse the command line
    parser = argparse.ArgumentParser(usage='%(prog)s [options] host')
    parser.add_argument('host')
    parser.add_argument('-d', '--debug', action='store_true', help='output only raw JSON from scan and tests')
    parser.add_argument('-v', '--verbose', action='store_true', help='don\'t display progress information')
    args = parser.parse_args()

    # Go out and scan!
    analyze(args.host)
